{
    "collab_server" : "",
    "contents" : "#packages <- c('tuneR', 'seewave', 'gbm')\n#if (length(setdiff(packages, rownames(installed.packages()))) > 0) {\n#  install.packages(setdiff(packages, rownames(installed.packages())))  \n#}\n\nlibrary(tuneR)\nlibrary(seewave)\nlibrary(gbm)\nlibrary(xgboost)\nlibrary(randomForest)\nlibrary(e1071)\n\nspecan3 <- function(X, bp = c(0,22), wl = 2048, threshold = 5, parallel = 1){\n  # To use parallel processing: library(devtools), install_github('nathanvan/parallelsugar')\n  if(class(X) == \"data.frame\") {if(all(c(\"sound.files\", \"selec\", \n                                         \"start\", \"end\") %in% colnames(X))) \n  {\n    start <- as.numeric(unlist(X$start))\n    end <- as.numeric(unlist(X$end))\n    sound.files <- as.character(unlist(X$sound.files))\n    selec <- as.character(unlist(X$selec))\n  } else stop(paste(paste(c(\"sound.files\", \"selec\", \"start\", \"end\")[!(c(\"sound.files\", \"selec\", \n                                                                        \"start\", \"end\") %in% colnames(X))], collapse=\", \"), \"column(s) not found in data frame\"))\n  } else  stop(\"X is not a data frame\")\n  \n  #if there are NAs in start or end stop\n  if(any(is.na(c(end, start)))) stop(\"NAs found in start and/or end\")  \n  \n  #if end or start are not numeric stop\n  if(all(class(end) != \"numeric\" & class(start) != \"numeric\")) stop(\"'end' and 'selec' must be numeric\")\n  \n  #if any start higher than end stop\n  if(any(end - start<0)) stop(paste(\"The start is higher than the end in\", length(which(end - start<0)), \"case(s)\"))  \n  \n  #if any selections longer than 20 secs stop\n  if(any(end - start>20)) stop(paste(length(which(end - start>20)), \"selection(s) longer than 20 sec\"))  \n  options( show.error.messages = TRUE)\n  \n  #if bp is not vector or length!=2 stop\n  if(!is.vector(bp)) stop(\"'bp' must be a numeric vector of length 2\") else{\n    if(!length(bp) == 2) stop(\"'bp' must be a numeric vector of length 2\")}\n  \n  #return warning if not all sound files were found\n  fs <- list.files(path = getwd(), pattern = \".wav$\", ignore.case = TRUE)\n  if(length(unique(sound.files[(sound.files %in% fs)])) != length(unique(sound.files))) \n    cat(paste(length(unique(sound.files))-length(unique(sound.files[(sound.files %in% fs)])), \n              \".wav file(s) not found\"))\n  \n  #count number of sound files in working directory and if 0 stop\n  d <- which(sound.files %in% fs) \n  if(length(d) == 0){\n    stop(\"The .wav files are not in the working directory\")\n  }  else {\n    start <- start[d]\n    end <- end[d]\n    selec <- selec[d]\n    sound.files <- sound.files[d]\n  }\n  \n  # If parallel is not numeric\n  if(!is.numeric(parallel)) stop(\"'parallel' must be a numeric vector of length 1\") \n  if(any(!(parallel %% 1 == 0),parallel < 1)) stop(\"'parallel' should be a positive integer\")\n  \n  # If parallel was called\n   if(parallel > 1)\n   { options(warn = -1)\n     if(all(Sys.info()[1] == \"Windows\",requireNamespace(\"parallelsugar\", quietly = TRUE) == TRUE)) \n       lapp <- function(X, FUN) parallelsugar::mclapply(X, FUN, mc.cores = parallel) else\n         if(Sys.info()[1] == \"Windows\"){ \n           cat(\"Windows users need to install the 'parallelsugar' package for parallel computing (you are not doing it now!)\")\n           lapp <- pbapply::pblapply} else lapp <- function(X, FUN) parallel::mclapply(X, FUN, mc.cores = parallel)} else lapp <- pbapply::pblapply\n  \n  options(warn = 0)\n  \n  wave <- NULL\n  \n  if(parallel == 1) cat(\"Measuring acoustic parameters:\")\n  x <- as.data.frame(lapp(1:length(start), function(i) { \n    r <- tuneR::readWave(file.path(getwd(), sound.files[i]), from = start[i], to = end[i], units = \"seconds\") \n    \n    b<- bp #in case bp its higher than can be due to sampling rate\n    if(b[2] > ceiling(r@samp.rate/2000) - 1) b[2] <- ceiling(r@samp.rate/2000) - 1 \n    \n    \n    #frequency spectrum analysis\n    songspec <- seewave::spec(r, f = r@samp.rate, plot = FALSE)\n    analysis <- seewave::specprop(songspec, f = r@samp.rate, flim = c(0, 280/1000), plot = FALSE)\n    \n    #save parameters\n    meanfreq <- analysis$mean/1000\n    sd <- analysis$sd/1000\n    median <- analysis$median/1000\n    Q25 <- analysis$Q25/1000\n    Q75 <- analysis$Q75/1000\n    IQR <- analysis$IQR/1000\n    skew <- analysis$skewness\n    kurt <- analysis$kurtosis\n    sp.ent <- analysis$sh\n    sfm <- analysis$sfm\n    mode <- analysis$mode/1000\n    centroid <- analysis$cent/1000\n    \n    #Frequency with amplitude peaks\n    peakf <- 0#seewave::fpeaks(songspec, f = r@samp.rate, wl = wl, nmax = 3, plot = FALSE)[1, 1]\n    \n    #Fundamental frequency parameters\n    ff <- seewave::fund(r, f = r@samp.rate, ovlp = 50, threshold = threshold, \n                        fmax = 280, ylim=c(0, 280/1000), plot = FALSE, wl = wl)[, 2]\n    meanfun<-mean(ff, na.rm = T)\n    minfun<-min(ff, na.rm = T)\n    maxfun<-max(ff, na.rm = T)\n    \n    #Dominant frecuency parameters\n    y <- seewave::dfreq(r, f = r@samp.rate, wl = wl, ylim=c(0, 280/1000), ovlp = 0, plot = F, threshold = threshold, bandpass = b * 1000, fftw = TRUE)[, 2]\n    meandom <- mean(y, na.rm = TRUE)\n    mindom <- min(y, na.rm = TRUE)\n    maxdom <- max(y, na.rm = TRUE)\n    dfrange <- (maxdom - mindom)\n    duration <- (end[i] - start[i])\n    \n    #modulation index calculation\n    changes <- vector()\n    for(j in which(!is.na(y))){\n      change <- abs(y[j] - y[j + 1])\n      changes <- append(changes, change)\n    }\n    if(mindom==maxdom) modindx<-0 else modindx <- mean(changes, na.rm = T)/dfrange\n\n    wave <<- r\n    \n    #save results\n    return(c(duration, meanfreq, sd, median, Q25, Q75, IQR, skew, kurt, sp.ent, sfm, mode, \n             centroid, peakf, meanfun, minfun, maxfun, meandom, mindom, maxdom, dfrange, modindx))\n  }))\n  \n  #change result names\n  \n  rownames(x) <- c(\"duration\", \"meanfreq\", \"sd\", \"median\", \"Q25\", \"Q75\", \"IQR\", \"skew\", \"kurt\", \"sp.ent\", \n                   \"sfm\",\"mode\", \"centroid\", \"peakf\", \"meanfun\", \"minfun\", \"maxfun\", \"meandom\", \"mindom\", \"maxdom\", \"dfrange\", \"modindx\")\n  x <- data.frame(sound.files, selec, as.data.frame(t(x)))\n  colnames(x)[1:2] <- c(\"sound.files\", \"selec\")\n  rownames(x) <- c(1:nrow(x))\n  \n  return(list(acoustics = x, wave = wave))\n}\n\nprocessFolder <- function(folderName) {\n  # Start with empty data.frame.\n  data <- data.frame()\n  \n  # Get list of files in the folder.\n  list <- list.files(folderName, '\\\\.wav')\n  \n  # Add file list to data.frame for processing.\n  for (fileName in list) {\n    row <- data.frame(fileName, 0, 0, 20)\n    data <- rbind(data, row)\n  }\n  \n  # Set column names.\n  names(data) <- c('sound.files', 'selec', 'start', 'end')\n  \n  # Move into folder for processing.\n  setwd(folderName)\n  \n  # Process files.\n  result <- specan3(data, parallel=1)\n  \n  # Move back into parent folder.\n  setwd('..')\n  \n  result$acoustics\n}\n\ngender <- function(filePath, model = 1, session = NULL) {\n  if (model == 1) {\n    print('Using model: SVM')\n    if (!exists('genderSvm')) {\n      load('data/svm.bin')\n    }\n    \n    fit <- genderSvm\n  }\n  else if (model == 2) {\n    print('Using model: XGBoost Small')\n    if (!exists('genderXG')) {\n      load('data/xgboostSmall.bin')\n    }\n   \n    fit <- genderXG\n  }\n  else if (model == 3) {\n    print('Using model: Tuned Random Forest')\n    if (!exists('genderTunedForest')) {\n      load('data/tunedForest.bin')\n    }\n    \n    fit <- genderTunedForest\n  }\n  else if (model == 4) {\n    print('Using model: XGBoost Large')\n    if (!exists('genderXG2')) {\n      load('data/xgboostLarge.bin')\n    }\n    \n    fit <- genderXG2\n  }\n  else if (model == 5) {\n    print('Using model: Stacked ensemble')\n    if (!exists('genderStacked')) {\n      load('data/stacked.bin')\n    }\n    if (!exists('genderTunedForest')) {\n      load('data/tunedForest.bin')\n    }\n    if (!exists('genderXG2')) {\n      load('data/xgboostLarge.bin')\n    }\n    if (!exists('genderSvm')) {\n      load('data/svm.bin')\n    }\n    \n    fit <- genderStacked\n  }\n  \n  # Setup paths.\n  currentPath <- getwd()\n  fileName <- basename(filePath)\n  path <- dirname(filePath)\n  \n  print(path)\n  print(fileName)\n  \n  # Set directory to read file.\n  setwd(path)\n  print(getwd())\n  \n  # Start with empty data.frame.\n  data <- data.frame(fileName, 0, 0, 20)\n  \n  # Set column names.\n  names(data) <- c('sound.files', 'selec', 'start', 'end')\n  \n  if (is.null(session)) {\n    # Process files.\n    result <- specan3(data, parallel=1)\n    \n    acoustics <- result$acoustics\n    acoustics[,1:3] <- NULL\n    acoustics[,'peakf'] <- NULL\n    \n    wave <- result$wave\n\n    acoustics <- as.matrix(acoustics)\n  }\n  else {\n    acoustics <- session$acoustics\n    wave <- session$wave\n  }\n  \n  # Restore path.\n  setwd(currentPath)\n\n  if (model != 5) {\n    result <- predict(fit, newdata=acoustics)\n    print(result)\n  }\n  \n  if (model == 1) {\n    prob <- 0\n  }\n  else if (model == 3) {\n    prob <- predict(fit, newdata=acoustics, type='prob')[,2]\n    print(prob)\n  }\n  else if (model == 2 || model == 4) {\n    prob <- result\n    mf <- as.factor(c('male', 'female'))\n    if (prob >= 0.4) {\n      result <- mf[2]\n    }\n    else {\n      result <- mf[1]\n    }\n  }\n  else if (model == 5) {\n    results1 <- predict(genderSvm, newdata=acoustics)\n    results2 <- predict(genderTunedForest, newdata=acoustics)\n\n    mf <- as.factor(c('male', 'female'))\n    prob <- predict(genderXG2, newdata=acoustics)\n    if (prob >= 0.5) {\n      results3 <- mf[2]\n    }\n    else {\n      results3 <- mf[1]\n    }\n    \n    combo <- data.frame(results1, results2, results3)\n    \n    prob <- predict(genderStacked, newdata=combo, type='prob')[,2]\n    result <- predict(genderStacked, newdata=combo)\n    \n    print(result)\n  }\n  \n  list(label = result, prob = prob, acoustics = acoustics, wave = wave)\n}\n",
    "created" : 1503023626379.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2216010069",
    "id" : "5A7A7EBC",
    "lastKnownWriteTime" : 1503023945,
    "last_content_update" : 1503023945832,
    "path" : "~/Documents/voice-gender-master/Web/gender.R",
    "project_path" : "Web/gender.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}