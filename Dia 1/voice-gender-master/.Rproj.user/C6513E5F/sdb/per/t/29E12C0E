{
    "collab_server" : "",
    "contents" : "packages <- c('tuneR', 'seewave', 'fftw', 'caTools', 'randomForest', 'warbleR', 'mice', 'e1071', 'rpart', 'rpart-plot', 'xgboost', 'e1071')\nif (length(setdiff(packages, rownames(installed.packages()))) > 0) {\n  install.packages(setdiff(packages, rownames(installed.packages())))  \n}\nlibrary(tuneR)\nlibrary(seewave)\nlibrary(caTools)\nlibrary(rpart)\nlibrary(rpart.plot)\nlibrary(randomForest)\nlibrary(warbleR)\nlibrary(mice)\nlibrary(xgboost)\nlibrary(e1071)\n\nspecan3 <- function(X, bp = c(0,22), wl = 2048, threshold = 5, parallel = 1){\n  # To use parallel processing: library(devtools), install_github('nathanvan/parallelsugar')\n  if(class(X) == \"data.frame\") {if(all(c(\"sound.files\", \"selec\", \n                                         \"start\", \"end\") %in% colnames(X))) \n  {\n    start <- as.numeric(unlist(X$start))\n    end <- as.numeric(unlist(X$end))\n    sound.files <- as.character(unlist(X$sound.files))\n    selec <- as.character(unlist(X$selec))\n  } else stop(paste(paste(c(\"sound.files\", \"selec\", \"start\", \"end\")[!(c(\"sound.files\", \"selec\", \n                                                                        \"start\", \"end\") %in% colnames(X))], collapse=\", \"), \"column(s) not found in data frame\"))\n  } else  stop(\"X is not a data frame\")\n  \n  #if there are NAs in start or end stop\n  if(any(is.na(c(end, start)))) stop(\"NAs found in start and/or end\")  \n  \n  #if end or start are not numeric stop\n  if(all(class(end) != \"numeric\" & class(start) != \"numeric\")) stop(\"'end' and 'selec' must be numeric\")\n  \n  #if any start higher than end stop\n  if(any(end - start<0)) stop(paste(\"The start is higher than the end in\", length(which(end - start<0)), \"case(s)\"))  \n  \n  #if any selections longer than 20 secs stop\n  if(any(end - start>20)) stop(paste(length(which(end - start>20)), \"selection(s) longer than 20 sec\"))  \n  options( show.error.messages = TRUE)\n  \n  #if bp is not vector or length!=2 stop\n  if(!is.vector(bp)) stop(\"'bp' must be a numeric vector of length 2\") else{\n    if(!length(bp) == 2) stop(\"'bp' must be a numeric vector of length 2\")}\n  \n  #return warning if not all sound files were found\n  fs <- list.files(path = getwd(), pattern = \".wav$\", ignore.case = TRUE)\n  if(length(unique(sound.files[(sound.files %in% fs)])) != length(unique(sound.files))) \n    cat(paste(length(unique(sound.files))-length(unique(sound.files[(sound.files %in% fs)])), \n              \".wav file(s) not found\"))\n  \n  #count number of sound files in working directory and if 0 stop\n  d <- which(sound.files %in% fs) \n  if(length(d) == 0){\n    stop(\"The .wav files are not in the working directory\")\n  }  else {\n    start <- start[d]\n    end <- end[d]\n    selec <- selec[d]\n    sound.files <- sound.files[d]\n  }\n  \n  # If parallel is not numeric\n  if(!is.numeric(parallel)) stop(\"'parallel' must be a numeric vector of length 1\") \n  if(any(!(parallel %% 1 == 0),parallel < 1)) stop(\"'parallel' should be a positive integer\")\n  \n  # If parallel was called\n  if(parallel > 1)\n  { options(warn = -1)\n    if(all(Sys.info()[1] == \"Windows\",requireNamespace(\"parallelsugar\", quietly = TRUE) == TRUE)) \n      lapp <- function(X, FUN) parallelsugar::mclapply(X, FUN, mc.cores = parallel) else\n        if(Sys.info()[1] == \"Windows\"){ \n          cat(\"Windows users need to install the 'parallelsugar' package for parallel computing (you are not doing it now!)\")\n          lapp <- pbapply::pblapply} else lapp <- function(X, FUN) parallel::mclapply(X, FUN, mc.cores = parallel)} else lapp <- pbapply::pblapply\n  \n  options(warn = 0)\n  \n  if(parallel == 1) cat(\"Measuring acoustic parameters:\")\n  x <- as.data.frame(lapp(1:length(start), function(i) { \n    r <- tuneR::readWave(file.path(getwd(), sound.files[i]), from = start[i], to = end[i], units = \"seconds\") \n    \n    b<- bp #in case bp its higher than can be due to sampling rate\n    if(b[2] > ceiling(r@samp.rate/2000) - 1) b[2] <- ceiling(r@samp.rate/2000) - 1 \n    \n    \n    #frequency spectrum analysis\n    songspec <- seewave::spec(r, f = r@samp.rate, plot = FALSE)\n    analysis <- seewave::specprop(songspec, f = r@samp.rate, flim = c(0, 280/1000), plot = FALSE)\n    \n    #save parameters\n    meanfreq <- analysis$mean/1000\n    sd <- analysis$sd/1000\n    median <- analysis$median/1000\n    Q25 <- analysis$Q25/1000\n    Q75 <- analysis$Q75/1000\n    IQR <- analysis$IQR/1000\n    skew <- analysis$skewness\n    kurt <- analysis$kurtosis\n    sp.ent <- analysis$sh\n    sfm <- analysis$sfm\n    mode <- analysis$mode/1000\n    centroid <- analysis$cent/1000\n    \n    #Frequency with amplitude peaks\n    peakf <- 0#seewave::fpeaks(songspec, f = r@samp.rate, wl = wl, nmax = 3, plot = FALSE)[1, 1]\n    \n    #Fundamental frequency parameters\n    ff <- seewave::fund(r, f = r@samp.rate, ovlp = 50, threshold = threshold, \n                        fmax = 280, ylim=c(0, 280/1000), plot = FALSE, wl = wl)[, 2]\n    meanfun<-mean(ff, na.rm = T)\n    minfun<-min(ff, na.rm = T)\n    maxfun<-max(ff, na.rm = T)\n    \n    #Dominant frecuency parameters\n    y <- seewave::dfreq(r, f = r@samp.rate, wl = wl, ylim=c(0, 280/1000), ovlp = 0, plot = F, threshold = threshold, bandpass = b * 1000, fftw = TRUE)[, 2]\n    meandom <- mean(y, na.rm = TRUE)\n    mindom <- min(y, na.rm = TRUE)\n    maxdom <- max(y, na.rm = TRUE)\n    dfrange <- (maxdom - mindom)\n    duration <- (end[i] - start[i])\n    \n    #modulation index calculation\n    changes <- vector()\n    for(j in which(!is.na(y))){\n      change <- abs(y[j] - y[j + 1])\n      changes <- append(changes, change)\n    }\n    if(mindom==maxdom) modindx<-0 else modindx <- mean(changes, na.rm = T)/dfrange\n    \n    #save results\n    return(c(duration, meanfreq, sd, median, Q25, Q75, IQR, skew, kurt, sp.ent, sfm, mode, \n             centroid, peakf, meanfun, minfun, maxfun, meandom, mindom, maxdom, dfrange, modindx))\n  }))\n  \n  #change result names\n  \n  rownames(x) <- c(\"duration\", \"meanfreq\", \"sd\", \"median\", \"Q25\", \"Q75\", \"IQR\", \"skew\", \"kurt\", \"sp.ent\", \n                   \"sfm\",\"mode\", \"centroid\", \"peakf\", \"meanfun\", \"minfun\", \"maxfun\", \"meandom\", \"mindom\", \"maxdom\", \"dfrange\", \"modindx\")\n  x <- data.frame(sound.files, selec, as.data.frame(t(x)))\n  colnames(x)[1:2] <- c(\"sound.files\", \"selec\")\n  rownames(x) <- c(1:nrow(x))\n  \n  return(x)\n}\n\nprocessFolder <- function(folderName) {\n  # Start with empty data.frame.\n  data <- data.frame()\n  \n  # Get list of files in the folder.\n  list <- list.files(folderName, '\\\\.wav')\n  \n  # Add file list to data.frame for processing.\n  for (fileName in list) {\n    row <- data.frame(fileName, 0, 0, 20)\n    data <- rbind(data, row)\n  }\n  \n  # Set column names.\n  names(data) <- c('sound.files', 'selec', 'start', 'end')\n  \n  # Move into folder for processing.\n  setwd(folderName)\n  \n  # Process files.\n  acoustics <- specan3(data, parallel=1)\n  \n  # Move back into parent folder.\n  setwd('..')\n  \n  acoustics\n}\n\ngender <- function(filePath) {\n  if (!exists('genderBoosted')) {\n    load('model.bin')\n  }\n  \n  # Setup paths.\n  currentPath <- getwd()\n  fileName <- basename(filePath)\n  path <- dirname(filePath)\n  \n  # Set directory to read file.\n  setwd(path)\n  \n  # Start with empty data.frame.\n  data <- data.frame(fileName, 0, 0, 20)\n  \n  # Set column names.\n  names(data) <- c('sound.files', 'selec', 'start', 'end')\n  \n  # Process files.\n  acoustics <- specan3(data, parallel=1)\n  \n  # Restore path.\n  setwd(currentPath)\n  \n  predict(genderCombo, newdata=acoustics)\n}\n\n# Load data\nmales <- processFolder('male')\nfemales <- processFolder('female')\n\n# Set labels.\nmales$label <- 1\nfemales$label <- 2\ndata <- rbind(males, females)\ndata$label <- factor(data$label, labels=c('male', 'female'))\n\n# Remove unused columns.\ndata$duration <- NULL\ndata$sound.files <- NULL\ndata$selec <- NULL\ndata$peakf <- NULL\n\n# Remove rows containing NA's.\ndata <- data[complete.cases(data),]\n\n# Write out csv dataset.\nwrite.csv(data, file='voice.csv', sep=',', row.names=F)\n\n# Create a train and test set.\nset.seed(777)\nspl <- sample.split(data$label, 0.7)\ntrain <- subset(data, spl == TRUE)\ntest <- subset(data, spl == FALSE)\n\n# Build models.\ngenderLog <- glm(label ~ ., data=train, family='binomial')\ngenderCART <- rpart(label ~ ., data=train, method='class')\nprp(genderCART)\ngenderForest <- randomForest(label ~ ., data=train)\n\n# Assume a basline model of always predicting male.\n# Accuracy: 0.50\ntable(train$label)\n1107 / nrow(train)\n\n# Accuracy: 0.50\ntable(test$label)\n475 / nrow(test)\n\n# Accuracy: 0.72\npredictLog <- predict(genderLog, type='response')\ntable(train$label, predictLog >= 0.5)\n(814 + 777) / nrow(train)\n\n# Accuracy: 0.71\npredictLog2 <- predict(genderLog, newdata=test, type='response')\ntable(test$label, predictLog2 >= 0.5)\n(339 + 335) / nrow(test)\n\n# Accuracy: 0.81\npredictCART <- predict(genderCART)\npredictCART.prob <- predictCART[,2]\ntable(train$label, predictCART.prob >= 0.5)\n(858 + 941) / nrow(train)\n\n# Accuracy: 0.78\npredictCART2 <- predict(genderCART, newdata=test)\npredictCART2.prob <- predictCART2[,2]\ntable(test$label, predictCART2.prob >= 0.5)\n(364 + 378) / nrow(test)\n\n# Accuracy: 1\npredictForest <- predict(genderForest, newdata=train)\ntable(train$label, predictForest)\n\n# Accuracy: 0.86\npredictForest <- predict(genderForest, newdata=test)\ntable(test$label, predictForest)\n(410 + 409) / nrow(test)\n\n# Tune random-forest and return best model.\n# Accuracy: 0.87\nset.seed(777)\ngenderTunedForest <- tuneRF(train[, -21], train[, 21], stepFactor=.5, doBest=TRUE)\npredictForest <- predict(genderTunedForest, newdata=test)\ntable(test$label, predictForest)\n(412 + 416) / nrow(test)\n\n# Try svm (gamma and cost determined from tuning).\nset.seed(777)\ngenderSvm <- svm(label ~ ., data=train, gamma=0.21, cost=8)\n\n# Accuracy: 0.96\npredictSvm <- predict(genderSvm, train)\ntable(predictSvm, train$label)\n(1076+1058)/nrow(train)\n\n# Accuracy: 0.85\npredictSvm <- predict(genderSvm, test)\ntable(predictSvm, test$label)\n(423+386)/nrow(test)\n\n# With no tuning, Accuracy: 0.84\n#predictSvm <- predict(genderSvm, train)\n#table(predictSvm, train$label)\n#(954 + 902) / nrow(train)\n\n# Accuracy: 0.81\n#predictSvm <- predict(genderSvm, test)\n#table(predictSvm, test$label)\n\n# Try a tuned svm.\n#set.seed(777)\n#svmTune <- tune.svm(label ~ ., data=train, sampling='fix', gamma = 2^c(-8,-4,0,4), cost = 2^c(-8,-4,-2,0))\n# The darker blue is the best values for a model.\n#plot(svmTune)\n\n# We can re-run the tuning with more specific values for gamma (epsilon) and cost.\n#set.seed(777)\n#svmTune <- tune.svm(label ~ ., data=train, sampling='fix', gamma = seq(0, 0.2, 0.01), cost = c(1, 2, 4))\n#genderSvm <- svmTune$best.model\n#plot(svmTune)\n\n# Accuracy: 0.91\n#predictSvm <- predict(genderSvm, train)\n#table(predictSvm, train$label)\n#(1023+1003)/nrow(train)\n\n# Accuracy: 0.83\n#predictSvm <- predict(genderSvm, test)\n#table(predictSvm, test$label)\n#(407+384)/nrow(test)\n\n# Narrow down one more time.\n#set.seed(777)\n#svmTune <- tune.svm(label ~ ., data=train, sampling='fix', gamma = seq(0.2, 0.3, 0.01), cost = c(3, 5, 8))\n#genderSvm <- svmTune$best.model\n#plot(svmTune)\n\n# Accuracy: 0.96\n#predictSvm <- predict(genderSvm, train)\n#table(predictSvm, train$label)\n#(1076+1058)/nrow(train)\n\n# Accuracy: 0.85\n#predictSvm <- predict(genderSvm, test)\n#table(predictSvm, test$label)\n#(423+386)/nrow(test)\n\n# One final tuning.\n#set.seed(777)\n#svmTune <- tune.svm(label ~ ., data=train, sampling='fix', gamma = seq(0.2, 0.25, 0.01), cost = seq(8, 12, 1))\n#genderSvm <- svmTune$best.model\n#plot(svmTune)\n\n# Accuracy: 0.97\n#predictSvm <- predict(genderSvm, train)\n#table(predictSvm, train$label)\n#(1079+1065)/nrow(train)\n\n# Accuracy: 0.85 (one less, so very tiny overfitting)\n#predictSvm <- predict(genderSvm, test)\n#table(predictSvm, test$label)\n#(422+386)/nrow(test)\n\n# Try a boosted tree model.\n# Accuracy: 0.91\n#set.seed(777)\n#genderBoosted <- train(label ~ ., data=train, method='gbm')\n#predictBoosted <- predict(genderBoosted, newdata=train)\n#confusionMatrix(predictBoosted, train$label)\n\n# Accuracy: 0.84\n#predictBoosted <- predict(genderBoosted, newdata=test)\n#confusionMatrix(predictBoosted, test$label)\n\n# Try XGBoost.\n# Accuracy: 1\ntrainx <- sapply(train, as.numeric)\ntrainx[,21] <- trainx[,21] - 1\nset.seed(777)\ngenderXG <- xgboost(data = trainx[,-21], label = trainx[,21], eta=0.2, nround = 500, subsample = 0.5, colsample_bytree = 0.5, objective = \"binary:logistic\")\nresults <- predict(genderXG, trainx)\ntable(trainx[,21], results >= 0.5)\n\n# Accuracy: 0.87\ntestx <- sapply(test, as.numeric)\ntestx[,21] <- testx[,21] - 1\nresults <- predict(genderXG, testx)\ntable(testx[,21], results >= 0.5)\n(414 + 413) / nrow(test)\n\n# Try stacking models in an ensemble.\nresults1 <- predict(genderSvm, newdata=test)\nresults2 <- predict(genderTunedForest, newdata=test)\nresults3 <- factor(as.numeric(predict(genderXG, testx) >= 0.5), labels = c('male', 'female'))\ncombo <- data.frame(results1, results2, results3, y = test$label)\n\n# Accuracy: 0.89\nset.seed(777)\ngenderStacked <- tuneRF(combo[,-4], combo[,4], stepFactor=.5, doBest=TRUE)\npredictStacked <- predict(genderStacked, newdata=combo)\ntable(predictStacked, test$label)\n\n# Accuracy: 1\nresults1 <- predict(genderSvm, newdata=train)\nresults2 <- predict(genderTunedForest, newdata=train)\nresults3 <- factor(as.numeric(predict(genderXG, trainx) >= 0.5), labels = c('male', 'female'))\ncombo <- data.frame(results1, results2, results3)\npredictStacked <- predict(genderStacked, newdata=combo)\ntable(predictStacked, train$label)\n\n# trans <- processFolder('sanity')\n# trans$label <- c(2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2)\n# trans$label <- factor(trans$label, labels=c('male', 'female'))\n# \n# tpred <- predict(genderTunedForest, newdata=trans)\n# table(trans$label, tpred)\n# \n# tpred <- predict(genderSvm, newdata=trans)\n# table(trans$label, tpred)\n# \n# trans[,1:3] <- NULL\n# trans$peakf <- NULL\n# testx <- sapply(trans, as.numeric)\n# testx[,21] <- testx[,21] - 1\n# results <- predict(genderXG, testx)\n# table(testx[,21], results >= 0.5)\n# \n# results1 <- predict(genderSvm, newdata=trans)\n# results2 <- predict(genderTunedForest, newdata=trans)\n# results3 <- factor(as.numeric(predict(genderXG, testx) >= 0.5), labels = c('male', 'female'))\n# combo <- data.frame(results1, results2, results3)\n# predictStacked <- predict(genderStacked, newdata=combo)\n# table(predictStacked, trans$label)\n\n\n\n# tpred <- predict(genderCART, newdata=trans)\n# tpred.prob <- tpred[,2]\n# table(trans$label, tpred.prob >= 0.5)\n\n# trans <- processFolder('trans2')\n# trans$label <- c(2, 2, 2, 1, 2)\n# trans$label <- factor(trans$label, labels=c('male', 'female'))\n# tpred <- predict(genderLog, newdata=trans, type='response')\n# table(trans$label, tpred >= 0.5)\n\n# tpred <- predict(genderForest, newdata=trans)\n# table(trans$label, tpred)\n\n# tpred <- predict(genderBoosted, newdata=trans)\n# confusionMatrix(trans$label, tpred)\n\n# tpred <- predict(genderCART, newdata=trans)\n# tpred.prob <- tpred[,2]\n# table(trans$label, tpred.prob >= 0.5)\n\n# trans <- processFolder('trans4')\n# trans$label <- c(2, 2, 2, 2, 1, 1, 1, 1)\n# trans$label <- factor(trans$label, labels=c('male', 'female'))\n# \n# tpred <- predict(genderLog, newdata=trans, type='response')\n# table(trans$label, tpred >= 0.5)\n# \n# tpred <- predict(genderTunedForest, newdata=trans, type='response')\n# table(trans$label, tpred)\n# \n# trans[,1:3] <- NULL\n# trans$peakf <- NULL\n# testx <- sapply(trans, as.numeric)\n# testx[,21] <- testx[,21] - 1\n# results <- predict(genderXG, testx)\n# table(testx[,21], results >= 0.5)\n",
    "created" : 1503016412369.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2123903685",
    "id" : "29E12C0E",
    "lastKnownWriteTime" : 1483376466,
    "last_content_update" : 1483376466,
    "path" : "~/Documents/voice-gender-master/sound.R",
    "project_path" : "sound.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}